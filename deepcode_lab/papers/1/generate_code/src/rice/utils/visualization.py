"""
Visualization utilities for the RICE system, providing specialized plotting and analysis tools.
"""

import os
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from typing import Dict, List, Optional, Union, Tuple
import torch
from matplotlib.figure import Figure
from matplotlib.axes import Axes


class RICEVisualizer:
    """
    Specialized visualization tools for RICE system analysis and results presentation.
    """
    
    def __init__(self, output_dir: str):
        """
        Initialize the visualizer with an output directory for saving plots.
        
        Args:
            output_dir (str): Directory where visualization outputs will be saved
        """
        self.output_dir = output_dir
        os.makedirs(output_dir, exist_ok=True)
        
        # Set style defaults
        plt.style.use('seaborn')
        sns.set_palette("husl")
        
    def plot_training_curves(self, 
                           metrics: Dict[str, List[float]], 
                           title: str = "Training Progress",
                           save_path: Optional[str] = None) -> Figure:
        """
        Plot training metrics over time.
        
        Args:
            metrics (Dict[str, List[float]]): Dictionary of metric names to lists of values
            title (str): Plot title
            save_path (Optional[str]): If provided, save plot to this path
            
        Returns:
            Figure: The generated matplotlib figure
        """
        fig, ax = plt.subplots(figsize=(10, 6))
        
        for metric_name, values in metrics.items():
            ax.plot(values, label=metric_name)
            
        ax.set_title(title)
        ax.set_xlabel("Episodes")
        ax.set_ylabel("Value")
        ax.legend()
        ax.grid(True)
        
        if save_path:
            fig.savefig(os.path.join(self.output_dir, save_path))
            
        return fig
    
    def plot_state_masks(self,
                        states: torch.Tensor,
                        masks: torch.Tensor,
                        num_samples: int = 5,
                        save_path: Optional[str] = None) -> Figure:
        """
        Visualize state masks generated by the explanation module.
        
        Args:
            states (torch.Tensor): Batch of states
            masks (torch.Tensor): Corresponding binary masks
            num_samples (int): Number of samples to visualize
            save_path (Optional[str]): If provided, save plot to this path
            
        Returns:
            Figure: The generated matplotlib figure
        """
        num_samples = min(num_samples, len(states))
        fig, axes = plt.subplots(num_samples, 2, figsize=(12, 3*num_samples))
        
        for i in range(num_samples):
            # Plot original state
            self._plot_state_vector(axes[i, 0], states[i].cpu().numpy(), 
                                  title=f"Original State {i+1}")
            
            # Plot masked state
            masked_state = states[i].cpu().numpy() * masks[i].cpu().numpy()
            self._plot_state_vector(axes[i, 1], masked_state,
                                  title=f"Masked State {i+1}")
        
        plt.tight_layout()
        
        if save_path:
            fig.savefig(os.path.join(self.output_dir, save_path))
            
        return fig
    
    def plot_exploration_analysis(self,
                                rnd_errors: List[float],
                                visited_states: torch.Tensor,
                                save_path: Optional[str] = None) -> Figure:
        """
        Visualize exploration analysis including RND prediction errors and state coverage.
        
        Args:
            rnd_errors (List[float]): RND prediction errors over time
            visited_states (torch.Tensor): States visited during training
            save_path (Optional[str]): If provided, save plot to this path
            
        Returns:
            Figure: The generated matplotlib figure
        """
        fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(10, 10))
        
        # Plot RND prediction errors
        ax1.plot(rnd_errors)
        ax1.set_title("RND Prediction Errors Over Time")
        ax1.set_xlabel("Steps")
        ax1.set_ylabel("Prediction Error")
        ax1.grid(True)
        
        # Plot state visitation density (2D projection if high-dimensional)
        states_np = visited_states.cpu().numpy()
        if states_np.shape[1] > 2:
            from sklearn.decomposition import PCA
            pca = PCA(n_components=2)
            states_2d = pca.fit_transform(states_np)
        else:
            states_2d = states_np
            
        sns.kdeplot(data=states_2d, ax=ax2)
        ax2.set_title("State Visitation Density")
        ax2.set_xlabel("State Dimension 1")
        ax2.set_ylabel("State Dimension 2")
        
        plt.tight_layout()
        
        if save_path:
            fig.savefig(os.path.join(self.output_dir, save_path))
            
        return fig
    
    def plot_policy_comparison(self,
                             original_actions: torch.Tensor,
                             refined_actions: torch.Tensor,
                             states: torch.Tensor,
                             save_path: Optional[str] = None) -> Figure:
        """
        Compare actions from original and refined policies.
        
        Args:
            original_actions (torch.Tensor): Actions from original policy
            refined_actions (torch.Tensor): Actions from refined policy
            states (torch.Tensor): States for which actions were taken
            save_path (Optional[str]): If provided, save plot to this path
            
        Returns:
            Figure: The generated matplotlib figure
        """
        fig, axes = plt.subplots(2, 2, figsize=(15, 12))
        
        # Action magnitude comparison
        orig_mag = torch.norm(original_actions, dim=1).cpu().numpy()
        refined_mag = torch.norm(refined_actions, dim=1).cpu().numpy()
        
        axes[0, 0].scatter(range(len(orig_mag)), orig_mag, alpha=0.5, label='Original')
        axes[0, 0].scatter(range(len(refined_mag)), refined_mag, alpha=0.5, label='Refined')
        axes[0, 0].set_title("Action Magnitudes")
        axes[0, 0].set_xlabel("Step")
        axes[0, 0].set_ylabel("Action Magnitude")
        axes[0, 0].legend()
        
        # Action difference histogram
        action_diff = torch.norm(original_actions - refined_actions, dim=1).cpu().numpy()
        axes[0, 1].hist(action_diff, bins=30)
        axes[0, 1].set_title("Action Differences")
        axes[0, 1].set_xlabel("L2 Distance")
        axes[0, 1].set_ylabel("Count")
        
        # State-conditioned action comparison (2D projection if needed)
        states_np = states.cpu().numpy()
        if states_np.shape[1] > 2:
            from sklearn.decomposition import PCA
            pca = PCA(n_components=2)
            states_2d = pca.fit_transform(states_np)
        else:
            states_2d = states_np
            
        scatter = axes[1, 0].scatter(states_2d[:, 0], states_2d[:, 1], 
                                   c=action_diff, cmap='viridis')
        axes[1, 0].set_title("Action Differences by State")
        axes[1, 0].set_xlabel("State Dim 1")
        axes[1, 0].set_ylabel("State Dim 2")
        plt.colorbar(scatter, ax=axes[1, 0])
        
        # Action correlation
        axes[1, 1].scatter(orig_mag, refined_mag, alpha=0.5)
        axes[1, 1].set_title("Action Correlation")
        axes[1, 1].set_xlabel("Original Action Magnitude")
        axes[1, 1].set_ylabel("Refined Action Magnitude")
        
        # Add correlation line
        min_mag = min(orig_mag.min(), refined_mag.min())
        max_mag = max(orig_mag.max(), refined_mag.max())
        axes[1, 1].plot([min_mag, max_mag], [min_mag, max_mag], 'r--', alpha=0.5)
        
        plt.tight_layout()
        
        if save_path:
            fig.savefig(os.path.join(self.output_dir, save_path))
            
        return fig
    
    @staticmethod
    def _plot_state_vector(ax: Axes, 
                          state: np.ndarray, 
                          title: str = "") -> None:
        """
        Helper method to plot a state vector.
        
        Args:
            ax (Axes): Matplotlib axes to plot on
            state (np.ndarray): State vector to plot
            title (str): Plot title
        """
        ax.bar(range(len(state)), state)
        ax.set_title(title)
        ax.set_xlabel("State Dimension")
        ax.set_ylabel("Value")